"use strict";(self.webpackChunkjavabrains_bootcamp=self.webpackChunkjavabrains_bootcamp||[]).push([[1688],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>h});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=a.createContext({}),d=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},p=function(e){var t=d(e.components);return a.createElement(l.Provider,{value:t},e.children)},c="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,l=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),c=d(n),u=i,h=c["".concat(l,".").concat(u)]||c[u]||m[u]||r;return n?a.createElement(h,s(s({ref:t},p),{},{components:n})):a.createElement(h,s({ref:t},p))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,s=new Array(r);s[0]=u;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o[c]="string"==typeof e?e:i,s[1]=o;for(var d=2;d<r;d++)s[d]=n[d];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},6222:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>c,frontMatter:()=>r,metadata:()=>o,toc:()=>d});var a=n(7462),i=(n(7294),n(3905));const r={},s="The List interface",o={unversionedId:"java-backend-bootcamp/java-collections/the-list-interface",id:"java-backend-bootcamp/java-collections/the-list-interface",title:"The List interface",description:"Introduction",source:"@site/docs/java-backend-bootcamp/java-collections/the-list-interface.md",sourceDirName:"java-backend-bootcamp/java-collections",slug:"/java-backend-bootcamp/java-collections/the-list-interface",permalink:"/java-backend-bootcamp/docs/java-backend-bootcamp/java-collections/the-list-interface",draft:!1,editUrl:"https://github.com/koushikkothagal/java-backend-bootcamp/tree/main/website/docs/java-backend-bootcamp/java-collections/the-list-interface.md",tags:[],version:"current",frontMatter:{},sidebar:"javaBackendBootcamp",previous:{title:"Time Complexity and Big O",permalink:"/java-backend-bootcamp/docs/java-backend-bootcamp/java-collections/time-complexity-and-big-o"},next:{title:"Comparable and Comparator",permalink:"/java-backend-bootcamp/docs/java-backend-bootcamp/java-collections/comparable-and-comparator"}},l={},d=[{value:"Introduction",id:"introduction",level:2},{value:"Implementations of the List Interface",id:"implementations-of-the-list-interface",level:2},{value:"ArrayList",id:"arraylist",level:3},{value:"LinkedList",id:"linkedlist",level:3},{value:"Vector",id:"vector",level:3},{value:"Common Methods of the List Interface",id:"common-methods-of-the-list-interface",level:2},{value:"List Interface and Generics",id:"list-interface-and-generics",level:2},{value:"List Interface and Autoboxing",id:"list-interface-and-autoboxing",level:2},{value:"CopyOnWriteArrayList",id:"copyonwritearraylist",level:2},{value:"Performance Considerations when working with the List Interface",id:"performance-considerations-when-working-with-the-list-interface",level:2},{value:"ArrayList performance",id:"arraylist-performance",level:3},{value:"LinkedList performance",id:"linkedlist-performance",level:3},{value:"ListIterator",id:"listiterator",level:2},{value:"SubList",id:"sublist",level:2}],p={toc:d};function c(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"the-list-interface"},"The List interface"),(0,i.kt)("h2",{id:"introduction"},"Introduction"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"List")," interface is a part of the Java Collection Framework and is used to represent an ordered collection. This means that the elements are stored in a specific order, and they can be accessed by their index. The ",(0,i.kt)("inlineCode",{parentName:"p"},"List")," interface extends the ",(0,i.kt)("inlineCode",{parentName:"p"},"Collection")," interface and adds additional methods for working with elements by their index."),(0,i.kt)("p",null,"Here is an example of creating a ",(0,i.kt)("inlineCode",{parentName:"p"},"List")," of ",(0,i.kt)("inlineCode",{parentName:"p"},"String"),"s:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},'import java.util.ArrayList;\nimport java.util.List;\n\npublic class ListExample {\n    public static void main(String[] args) {\n        // creating a list of strings\n        List<String> fruits = new ArrayList<>();\n\n        // adding elements to the list\n        fruits.add("apple");\n        fruits.add("banana");\n        fruits.add("orange");\n\n        // printing the list\n        System.out.println(fruits);\n    }\n}\n')),(0,i.kt)("p",null,"In this example, we created a List of Strings called fruits, and added elements to the list using the ",(0,i.kt)("inlineCode",{parentName:"p"},"add()")," method. We then printed the list, which will output: ",(0,i.kt)("inlineCode",{parentName:"p"},"[apple, banana, orange]"),"."),(0,i.kt)("p",null,"Another way of creating a List is by using the ",(0,i.kt)("inlineCode",{parentName:"p"},"Arrays.asList()")," method. This method creates a fixed-size list, it also accepts an array as an argument."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},'List<String> fruits = Arrays.asList("apple", "banana", "orange");\n')),(0,i.kt)("p",null,"You can also construct a List using ",(0,i.kt)("inlineCode",{parentName:"p"},"List.of"),". The resultant list is immutable (it cannot change) and it doesn't allow ",(0,i.kt)("inlineCode",{parentName:"p"},"null")," as an element."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},'List<String> fruits = List.of("apple", "banana", "orange");\n')),(0,i.kt)("p",null,"It is also possible to create a ",(0,i.kt)("inlineCode",{parentName:"p"},"List")," by copying the elements from another collection."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},'import java.util.ArrayList;\nimport java.util.List;\n\npublic class ListExample3 {\n    public static void main(String[] args) {\n        // creating a list of strings\n        List<String> fruits = new ArrayList<>();\n        fruits.add("apple");\n        fruits.add("banana");\n        fruits.add("orange");\n\n        // copying elements to another list\n        List<String> fruits2 = new ArrayList<>(fruits);\n\n        // printing the list\n        System.out.println(fruits2);\n    }\n}\n')),(0,i.kt)("p",null,"In this example, we created a new List called ",(0,i.kt)("inlineCode",{parentName:"p"},"fruits2")," and copied the elements from the ",(0,i.kt)("inlineCode",{parentName:"p"},"fruits")," list to it list by passing the original list as an argument to the ",(0,i.kt)("inlineCode",{parentName:"p"},"ArrayList")," constructor."),(0,i.kt)("p",null,"Note that in Java, the ",(0,i.kt)("inlineCode",{parentName:"p"},"List")," interface is implemented by several classes, such as ",(0,i.kt)("inlineCode",{parentName:"p"},"ArrayList"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"LinkedList")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"Vector"),". Each class has its own specific characteristics and is suited for different use cases. For example, ",(0,i.kt)("inlineCode",{parentName:"p"},"ArrayList")," is best for frequent random access, ",(0,i.kt)("inlineCode",{parentName:"p"},"LinkedList")," is best for frequent insertions and deletions, and ",(0,i.kt)("inlineCode",{parentName:"p"},"Vector")," is best for thread-safe operations."),(0,i.kt)("h2",{id:"implementations-of-the-list-interface"},"Implementations of the List Interface"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"List")," interface in Java is implemented by several classes, such as ",(0,i.kt)("inlineCode",{parentName:"p"},"ArrayList"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"LinkedList"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"Vector"),". Each class has its own specific characteristics and is suited for different use cases."),(0,i.kt)("h3",{id:"arraylist"},"ArrayList"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"ArrayList")," is the most commonly used implementation of the ",(0,i.kt)("inlineCode",{parentName:"p"},"List")," interface.\nIt is backed by an array, which means that it has a fixed size and when the number of elements in the list exceeds its capacity, a new array is created and all elements are copied to it.\nThe time complexity of most operations (e.g., add, get, set) is O(1) on average and O(n) in the worst case (when the array needs to be resized).\n",(0,i.kt)("inlineCode",{parentName:"p"},"ArrayList")," is best for frequent random access and when the number of elements in the list is relatively small.\nHere is an example of creating and using an ",(0,i.kt)("inlineCode",{parentName:"p"},"ArrayList"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},'import java.util.ArrayList;\nimport java.util.List;\n\npublic class ArrayListExample {\n    public static void main(String[] args) {\n        // creating an ArrayList of strings\n        List<String> fruits = new ArrayList<>();\n\n        // adding elements to the list\n        fruits.add("apple");\n        fruits.add("banana");\n        fruits.add("orange");\n\n        // accessing an element by index\n        System.out.println(fruits.get(1)); // output: banana\n\n        // removing an element by index\n        fruits.remove(1);\n        System.out.println(fruits); // output: [apple, orange]\n    }\n}\n')),(0,i.kt)("h3",{id:"linkedlist"},"LinkedList"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"LinkedList")," is implemented as a doubly-linked list, which means that each element in the list is connected to the next and previous elements.\nThe time complexity of most operations (e.g., add, get, set) is O(n) on average, but some operations, like append and remove at the end of the list, can be done in O(1).\n",(0,i.kt)("inlineCode",{parentName:"p"},"LinkedList")," is best for frequent insertions and deletions and when the number of elements in the list is relatively large.\nHere is an example of creating and using a ",(0,i.kt)("inlineCode",{parentName:"p"},"LinkedList"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},'import java.util.LinkedList;\nimport java.util.List;\n\npublic class LinkedListExample {\n    public static void main(String[] args) {\n        // creating a LinkedList of strings\n        List<String> fruits = new LinkedList<>();\n\n        // adding elements to the list\n        fruits.add("apple");\n        fruits.add("banana");\n        fruits.add("orange");\n\n        // accessing an element by index\n        System.out.println(fruits.get(1)); // O(n) operation. Output: banana\n\n        // removing an element by index\n        fruits.remove(2); //// O(1) operation.\n        System.out.println(fruits); // output: [apple, banana]\n    }\n}\n')),(0,i.kt)("h3",{id:"vector"},"Vector"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"Vector")," is similar to ArrayList, but it is synchronized, which means that it is thread-safe.\nThe time complexity of most operations (e.g., add, get, set) is O(1) on average and O(n) in the worst case (when the array needs to be resized).\n",(0,i.kt)("inlineCode",{parentName:"p"},"Vector")," is best for thread-safe operations, when multiple threads need to access the list simultaneously."),(0,i.kt)("p",null,"In conclusion, ",(0,i.kt)("inlineCode",{parentName:"p"},"ArrayList"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"LinkedList"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"Vector")," are three implementations of the ",(0,i.kt)("inlineCode",{parentName:"p"},"List")," interface in Java. Each class has its own specific characteristics and is suited for different use cases. ",(0,i.kt)("inlineCode",{parentName:"p"},"ArrayList")," is best for frequent random access, ",(0,i.kt)("inlineCode",{parentName:"p"},"LinkedList")," is best for frequent insertions and deletions, and ",(0,i.kt)("inlineCode",{parentName:"p"},"Vector")," is best for thread-safe operations. It's important to choose the right implementation according to your specific needs to achieve better performance and avoid unnecessary overheads."),(0,i.kt)("h2",{id:"common-methods-of-the-list-interface"},"Common Methods of the List Interface"),(0,i.kt)("p",null,"The List interface in Java provides several methods for working with elements in a list. The most commonly used methods are:"),(0,i.kt)("p",null,"add(E element): This method is used to add an element to the end of the list."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},'List<String> fruits = new ArrayList<>();\nfruits.add("apple");\nfruits.add("banana");\nfruits.add("orange");\n')),(0,i.kt)("p",null,"add(int index, E element): This method is used to add an element at a specific position in the list."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},'List<String> fruits = new ArrayList<>();\nfruits.add("apple");\nfruits.add("banana");\nfruits.add(1, "pear");\n')),(0,i.kt)("p",null,"get(int index): This method is used to retrieve an element at a specific position in the list."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},'List<String> fruits = new ArrayList<>();\nfruits.add("apple");\nfruits.add("banana");\nfruits.add("orange");\nString secondFruit = fruits.get(1);\n')),(0,i.kt)("p",null,"set(int index, E element): This method is used to update an element at a specific position in the list."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},'List<String> fruits = new ArrayList<>();\nfruits.add("apple");\nfruits.add("banana");\nfruits.add("orange");\nfruits.set(1, "pear");\n')),(0,i.kt)("p",null,"remove(int index): This method is used to remove an element at a specific position in the list."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},'List<String> fruits = new ArrayList<>();\nfruits.add("apple");\nfruits.add("banana");\nfruits.add("orange");\nfruits.remove(1);\n')),(0,i.kt)("p",null,"clear(): This method is used to remove all elements from the list."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},'List<String> fruits = new ArrayList<>();\nfruits.add("apple");\nfruits.add("banana");\nfruits.add("orange");\nfruits.clear();\n')),(0,i.kt)("p",null,"size(): This method is used to get the number of elements in the list."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},'List<String> fruits = new ArrayList<>();\nfruits.add("apple");\nfruits.add("banana");\nfruits.add("orange");\nint size = fruits.size();\n')),(0,i.kt)("p",null,"It's important to note that all these methods can throw an ",(0,i.kt)("inlineCode",{parentName:"p"},"IndexOutOfBoundsException")," if the index passed as an argument is out of the range of the list."),(0,i.kt)("h2",{id:"list-interface-and-generics"},"List Interface and Generics"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"List")," interface in Java can be used with generics to create a list of a specific type of object. Generics provide a way to specify the type of elements that a list can contain, which helps to prevent type casting errors and makes the code more readable."),(0,i.kt)("p",null,"Here is an example of creating a ",(0,i.kt)("inlineCode",{parentName:"p"},"List")," of Strings using generics:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},"// creating a list of strings using generics\nList<String> fruits = new ArrayList<>();\n")),(0,i.kt)("p",null,"In this example, we used the angle brackets (< and >) to specify that the list should contain only ",(0,i.kt)("inlineCode",{parentName:"p"},"String"),"s. This makes it clear that the list can only hold elements of type ",(0,i.kt)("inlineCode",{parentName:"p"},"String"),", and the compiler will prevent you from adding elements of any other type."),(0,i.kt)("p",null,"You can also create a ",(0,i.kt)("inlineCode",{parentName:"p"},"List")," of any other type, such as ",(0,i.kt)("inlineCode",{parentName:"p"},"List<Integer>"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"List<Double>"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"List<CustomObject>")," etc."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},"// creating a list of integers using generics\nList<Integer> numbers = new ArrayList<>();\n")),(0,i.kt)("h2",{id:"list-interface-and-autoboxing"},"List Interface and Autoboxing"),(0,i.kt)("p",null,"The List interface in Java can be used with autoboxing to store primitive data types. Autoboxing is a feature in Java that allows primitive data types to be automatically converted to their corresponding wrapper classes when they are used in a context where an object is expected. This means that primitive data types can be added to a List without the need to manually convert them to their corresponding wrapper classes."),(0,i.kt)("p",null,"Here is an example of creating a List of integers using autoboxing:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},"import java.util.ArrayList;\nimport java.util.List;\n\npublic class ListAutoboxingExample {\n    public static void main(String[] args) {\n        // creating a list of integers using autoboxing\n        List<Integer> numbers = new ArrayList<>();\n\n        // adding elements to the list using autoboxing\n        numbers.add(1);\n        numbers.add(2);\n        numbers.add(3);\n\n        // printing the list\n        System.out.println(numbers);\n    }\n}\n")),(0,i.kt)("p",null,"In this example, we created a List of integers, and added ",(0,i.kt)("inlineCode",{parentName:"p"},"int")," elements to the list using the ",(0,i.kt)("inlineCode",{parentName:"p"},"add()")," method. The primitive int data type is automatically converted to the ",(0,i.kt)("inlineCode",{parentName:"p"},"Integer")," wrapper class using autoboxing."),(0,i.kt)("p",null,"It's also possible to use autoboxing with other primitive data types such as double, float, long, short, byte and char. Here's an example of creating a List of doubles:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},"List<Double> numbers = new ArrayList<>();\n\n// adding elements to the list using autoboxing\nnumbers.add(1.1);\nnumbers.add(2.2);\nnumbers.add(3.3);\n")),(0,i.kt)("p",null,"It's important to note that autoboxing can also be used with other collections classes as well, such as ",(0,i.kt)("inlineCode",{parentName:"p"},"Set")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"Map"),"."),(0,i.kt)("h2",{id:"copyonwritearraylist"},"CopyOnWriteArrayList"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"CopyOnWriteArrayList")," is a thread-safe variant of ",(0,i.kt)("inlineCode",{parentName:"p"},"ArrayList")," in Java. It is a concurrent collection class that uses a copy-on-write strategy, which means that all modifications to the list are made on a copy of the underlying array. This ensures that multiple threads can read the list simultaneously without the need for locks, while still allowing for safe and efficient modification. This makes ",(0,i.kt)("inlineCode",{parentName:"p"},"CopyOnWriteArrayList")," well-suited for situations where many threads will be reading the list, but relatively few will be modifying it. However, because the array is copied on every modification, this class is less efficient than a standard ",(0,i.kt)("inlineCode",{parentName:"p"},"ArrayList")," when modifications are frequent."),(0,i.kt)("h2",{id:"performance-considerations-when-working-with-the-list-interface"},"Performance Considerations when working with the List Interface"),(0,i.kt)("h3",{id:"arraylist-performance"},"ArrayList performance"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"add() \u2013 On average: O(1). Worst-case scenario: O(n)(when there's no space and this results in new array + copy)"),(0,i.kt)("li",{parentName:"ul"},"add(index, element) \u2013 On average: O(n). Worst case scenario: Same as above"),(0,i.kt)("li",{parentName:"ul"},"get() \u2013 O(1)"),(0,i.kt)("li",{parentName:"ul"},"remove() \u2013 O(n) (Both index and object based)"),(0,i.kt)("li",{parentName:"ul"},"indexOf() \u2013 O(n)"),(0,i.kt)("li",{parentName:"ul"},"contains() \u2013 O(n)")),(0,i.kt)("h3",{id:"linkedlist-performance"},"LinkedList performance"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"add() \u2013 O(1) (Append at the end)"),(0,i.kt)("li",{parentName:"ul"},"add(index, element) \u2013 O(n)"),(0,i.kt)("li",{parentName:"ul"},"get() \u2013 O(n)"),(0,i.kt)("li",{parentName:"ul"},"remove() \u2013 O(n) (Both index and object based)"),(0,i.kt)("li",{parentName:"ul"},"contains() \u2013 O(n)")),(0,i.kt)("p",null,"Memory usage is also an important consideration when working with the ",(0,i.kt)("inlineCode",{parentName:"p"},"List")," interface. ",(0,i.kt)("inlineCode",{parentName:"p"},"ArrayList")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"Vector")," are backed by an array, which means that they have a fixed size and when the number of elements in the list exceeds its capacity, a new array is created and all elements are copied to it. ",(0,i.kt)("inlineCode",{parentName:"p"},"LinkedList"),", on the other hand, is implemented as a doubly-linked list, which means that each element in the list is connected to the next and previous elements. ",(0,i.kt)("inlineCode",{parentName:"p"},"LinkedList")," uses more memory than ",(0,i.kt)("inlineCode",{parentName:"p"},"ArrayList")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"Vector")," because it needs to store the links between elements in addition to the elements themselves."),(0,i.kt)("h1",{id:"additional-functionality-of-the-list-interface"},"Additional Functionality of the List Interface"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"List")," interface in Java provides additional functionality beyond the basic operations such as ",(0,i.kt)("inlineCode",{parentName:"p"},"add()"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"get()"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"set()"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"remove()"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"clear()"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"size()"),". Some of these additional functionalities include:"),(0,i.kt)("h2",{id:"listiterator"},"ListIterator"),(0,i.kt)("p",null,"This is an interface that allows you to iterate through a list in both forward and backward directions, and also allows you to modify the list during iteration. Here's an example of using a ",(0,i.kt)("inlineCode",{parentName:"p"},"ListIterator")," to iterate through a ",(0,i.kt)("inlineCode",{parentName:"p"},"List")," of ",(0,i.kt)("inlineCode",{parentName:"p"},"String"),"s:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},'import java.util.ArrayList;\nimport java.util.ListIterator;\n\npublic class BiDirectionalTraversal {\n    public static void main(String[] args) {\n        ArrayList<String> list = new ArrayList<>();\n        list.add("Item 1");\n        list.add("Item 2");\n        list.add("Item 3");\n        list.add("Item 4");\n        list.add("Item 5");\n\n        ListIterator<String> iterator = list.listIterator();\n\n        // Forward traversal using ListIterator\n        while (iterator.hasNext()) {\n            System.out.println(iterator.next());\n        }\n\n        // Backward traversal using ListIterator\n        while (iterator.hasPrevious()) {\n            System.out.println(iterator.previous());\n        }\n    }\n}\n')),(0,i.kt)("p",null,"The above code demonstrates how to use a ListIterator to do bi-directional traversal of an ArrayList. In the forward traversal, the next() method is used to get the next element in the list, and the hasNext() method is used to check if there are more elements in the list. Similarly, in the backward traversal, the previous() method is used to get the previous element in the list, and the hasPrevious() method is used to check if there are more elements in the reverse order."),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"The ",(0,i.kt)("inlineCode",{parentName:"p"},"listIterator()")," method returns an iterator that is positioned before the first element. Therefore, before starting the backward traversal, the iterator must be moved to the last element of the list using the ",(0,i.kt)("inlineCode",{parentName:"p"},"next()")," method as many times as the list size.")),(0,i.kt)("h2",{id:"sublist"},"SubList"),(0,i.kt)("p",null,'This is a method that allows you to return a "slice" of the list that is a sub-list of the original list. It returns a view of the portion of this list between the specified fromIndex, inclusive, and toIndex, exclusive. The returned list is backed by the original list, so changes to the original will reflect in the new one!'),(0,i.kt)("p",null,"Here's an example of creating a sub-list of a List of strings:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},'import java.util.ArrayList;\nimport java.util.List;\n\npublic class SubListExample {\n    public static void main(String[] args) {\n        List<String> fruits = new ArrayList<>();\n        fruits.add("apple");\n        fruits.add("banana");\n        fruits.add("orange");\n        fruits.add("pear");\n        fruits.add("mango");\n        fruits.add("kiwi");\n\n        List<String> subList = fruits.subList(1, 4);\n        System.out.println(subList); // [banana, orange, pear]\n\n        fruits.set(1, "bananaaaaa");\n        System.out.println(subList); // [bananaaaaa, orange, pear]\n\n    }\n}\n')))}c.isMDXComponent=!0}}]);