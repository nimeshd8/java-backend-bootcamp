"use strict";(self.webpackChunkjavabrains_bootcamp=self.webpackChunkjavabrains_bootcamp||[]).push([[9849],{3905:(e,a,n)=>{n.d(a,{Zo:()=>m,kt:()=>h});var t=n(7294);function r(e,a,n){return a in e?Object.defineProperty(e,a,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[a]=n,e}function p(e,a){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);a&&(t=t.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),n.push.apply(n,t)}return n}function i(e){for(var a=1;a<arguments.length;a++){var n=null!=arguments[a]?arguments[a]:{};a%2?p(Object(n),!0).forEach((function(a){r(e,a,n[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):p(Object(n)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(n,a))}))}return e}function l(e,a){if(null==e)return{};var n,t,r=function(e,a){if(null==e)return{};var n,t,r={},p=Object.keys(e);for(t=0;t<p.length;t++)n=p[t],a.indexOf(n)>=0||(r[n]=e[n]);return r}(e,a);if(Object.getOwnPropertySymbols){var p=Object.getOwnPropertySymbols(e);for(t=0;t<p.length;t++)n=p[t],a.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var o=t.createContext({}),s=function(e){var a=t.useContext(o),n=a;return e&&(n="function"==typeof e?e(a):i(i({},a),e)),n},m=function(e){var a=s(e.components);return t.createElement(o.Provider,{value:a},e.children)},u="mdxType",c={inlineCode:"code",wrapper:function(e){var a=e.children;return t.createElement(t.Fragment,{},a)}},d=t.forwardRef((function(e,a){var n=e.components,r=e.mdxType,p=e.originalType,o=e.parentName,m=l(e,["components","mdxType","originalType","parentName"]),u=s(n),d=r,h=u["".concat(o,".").concat(d)]||u[d]||c[d]||p;return n?t.createElement(h,i(i({ref:a},m),{},{components:n})):t.createElement(h,i({ref:a},m))}));function h(e,a){var n=arguments,r=a&&a.mdxType;if("string"==typeof e||r){var p=n.length,i=new Array(p);i[0]=d;var l={};for(var o in a)hasOwnProperty.call(a,o)&&(l[o]=a[o]);l.originalType=e,l[u]="string"==typeof e?e:r,i[1]=l;for(var s=2;s<p;s++)i[s]=n[s];return t.createElement.apply(null,i)}return t.createElement.apply(null,n)}d.displayName="MDXCreateElement"},3713:(e,a,n)=>{n.r(a),n.d(a,{assets:()=>o,contentTitle:()=>i,default:()=>u,frontMatter:()=>p,metadata:()=>l,toc:()=>s});var t=n(7462),r=(n(7294),n(3905));const p={},i="The Map interface",l={unversionedId:"java-backend-bootcamp/java-collections/the-map-interface",id:"java-backend-bootcamp/java-collections/the-map-interface",title:"The Map interface",description:"Introduction",source:"@site/docs/java-backend-bootcamp/java-collections/the-map-interface.md",sourceDirName:"java-backend-bootcamp/java-collections",slug:"/java-backend-bootcamp/java-collections/the-map-interface",permalink:"/java-backend-bootcamp/docs/java-backend-bootcamp/java-collections/the-map-interface",draft:!1,editUrl:"https://github.com/koushikkothagal/java-backend-bootcamp/tree/main/website/docs/java-backend-bootcamp/java-collections/the-map-interface.md",tags:[],version:"current",frontMatter:{},sidebar:"javaBackendBootcamp",previous:{title:"The Set interface",permalink:"/java-backend-bootcamp/docs/java-backend-bootcamp/java-collections/the-set-interface"},next:{title:"Java Lambdas and Streams",permalink:"/java-backend-bootcamp/docs/lambdas-and-streams"}},o={},s=[{value:"Introduction",id:"introduction",level:2},{value:"Implementations of the Map Interface",id:"implementations-of-the-map-interface",level:2},{value:"HashMap",id:"hashmap",level:3},{value:"LinkedHashMap",id:"linkedhashmap",level:3},{value:"TreeMap",id:"treemap",level:3},{value:"Performance Considerations when working with the Map Interface",id:"performance-considerations-when-working-with-the-map-interface",level:2},{value:"Time Complexity",id:"time-complexity",level:3},{value:"Memory usage",id:"memory-usage",level:3}],m={toc:s};function u(e){let{components:a,...n}=e;return(0,r.kt)("wrapper",(0,t.Z)({},m,n,{components:a,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"the-map-interface"},"The Map interface"),(0,r.kt)("h2",{id:"introduction"},"Introduction"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"Map")," interface is a part of the Java Collection Framework and it represents a collection of key-value pairs. It is similar to a dictionary in other programming languages."),(0,r.kt)("p",null,"The main characteristics of the Map interface are:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"It stores data in key-value pairs. Each key is unique and is used to retrieve the corresponding value."),(0,r.kt)("li",{parentName:"ol"},"The keys and values can be of any data type."),(0,r.kt)("li",{parentName:"ol"},"The ",(0,r.kt)("inlineCode",{parentName:"li"},"Map")," interface does not extend the ",(0,r.kt)("inlineCode",{parentName:"li"},"Collection")," interface, so it does not have the same methods as ",(0,r.kt)("inlineCode",{parentName:"li"},"List")," or ",(0,r.kt)("inlineCode",{parentName:"li"},"Set"),"."),(0,r.kt)("li",{parentName:"ol"},"The ",(0,r.kt)("inlineCode",{parentName:"li"},"Map")," interface has its own set of methods for adding, retrieving, and removing key-value pairs.")),(0,r.kt)("p",null,"Here is an example of how to create a ",(0,r.kt)("inlineCode",{parentName:"p"},"Map")," and add key-value pairs to it:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'import java.util.HashMap;\nimport java.util.Map;\n\npublic class Main {\n    public static void main(String[] args) {\n        // Create a new HashMap\n        Map<String, Integer> myMap = new HashMap<>();\n\n        // Add key-value pairs to the map\n        myMap.put("Apple", 1);\n        myMap.put("Banana", 2);\n        myMap.put("Cherry", 3);\n\n        // Print the map\n        System.out.println(myMap); // {Apple=1, Banana=2, Cherry=3}\n    }\n}\n\n')),(0,r.kt)("p",null,"In this example, we imported the ",(0,r.kt)("inlineCode",{parentName:"p"},"HashMap")," class and the ",(0,r.kt)("inlineCode",{parentName:"p"},"Map")," interface. We then created a new ",(0,r.kt)("inlineCode",{parentName:"p"},"HashMap"),'called "myMap" that uses strings as keys and integers as values. We added three key-value pairs to the map using the ',(0,r.kt)("inlineCode",{parentName:"p"},"put()")," method. Finally, we printed the map to see the key-value pairs it contains."),(0,r.kt)("h2",{id:"implementations-of-the-map-interface"},"Implementations of the Map Interface"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"Map")," interface provides a basic structure for storing data in key-value pairs, but it does not provide a specific implementation. Instead, several classes that implement the ",(0,r.kt)("inlineCode",{parentName:"p"},"Map")," interface are available in the Java Collection Framework, such as ",(0,r.kt)("inlineCode",{parentName:"p"},"HashMap"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"LinkedHashMap"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"TreeMap"),". Each of these classes has its own characteristics and use cases."),(0,r.kt)("h3",{id:"hashmap"},"HashMap"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"HashMap")," class is the most commonly used implementation of the ",(0,r.kt)("inlineCode",{parentName:"p"},"Map")," interface. It stores data in a hash table, which allows for fast retrieval of values using keys. However, it does not maintain the order of the key-value pairs."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'import java.util.HashMap;\nimport java.util.Map;\n\npublic class Main {\n    public static void main(String[] args) {\n        // Create a new HashMap\n        Map<String, Integer> myMap = new HashMap<>();\n\n        // Add key-value pairs to the map\n        myMap.put("Apple", 1);\n        myMap.put("Banana", 2);\n        myMap.put("Cherry", 3);\n\n        // Retrieve a value using a key\n        int value = myMap.get("Banana");\n        System.out.println(value); // 2\n    }\n}\n')),(0,r.kt)("h3",{id:"linkedhashmap"},"LinkedHashMap"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"LinkedHashMap")," class is similar to the ",(0,r.kt)("inlineCode",{parentName:"p"},"HashMap")," class, but it maintains the order of the key-value pairs based on the order they were added. This can be useful for maintaining the order of elements when iterating through the map."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'import java.util.LinkedHashMap;\nimport java.util.Map;\n\npublic class Main {\n    public static void main(String[] args) {\n        // Create a new LinkedHashMap\n        Map<String, Integer> myMap = new LinkedHashMap<>();\n\n        // Add key-value pairs to the map\n        myMap.put("Apple", 1);\n        myMap.put("Banana", 2);\n        myMap.put("Cherry", 3);\n\n        // Iterate through the map and print the key-value pairs\n        for (Map.Entry<String, Integer> entry : myMap.entrySet()) {\n            System.out.println(entry.getKey() + ": " + entry.getValue());\n        }\n    }\n}\n')),(0,r.kt)("p",null,"Output:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"Apple: 1\nBanana: 2\nCherry: 3\n")),(0,r.kt)("h3",{id:"treemap"},"TreeMap"),(0,r.kt)("p",null,"The TreeMap class implements ",(0,r.kt)("inlineCode",{parentName:"p"},"SortedMap")," and allows for fast retrieval of values using keys and also maintains the natural ordering of the keys. The map is sorted according to the natural ordering of its keys, or by a Comparator provided at map creation time, depending on which constructor is used."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'import java.util.Map;\nimport java.util.TreeMap;\n\npublic class Main {\n    public static void main(String[] args) {\n        // Create a new TreeMap\n        Map<String, Integer> myMap = new TreeMap<>();\n\n        // Add key-value pairs to the map\n        myMap.put("Apple", 1);\n        myMap.put("Banana", 2);\n        myMap.put("Cherry", 3);\n\n        // Iterate through the map and print the key-value pairs\n        for (Map.Entry<String, Integer> entry : myMap.entrySet()) {\n            System.out.println(entry.getKey() + ": " + entry.getEntry.getValue());\n        }\n    }\n}\n')),(0,r.kt)("p",null,"Output:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"Apple: 1\nBanana: 2\nCherry: 3\n")),(0,r.kt)("h1",{id:"common-methods-of-the-map-interface"},"Common Methods of the Map Interface"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"Map")," interface provides a set of methods for adding, retrieving, and removing key-value pairs. The following are some of the most commonly used methods:"),(0,r.kt)("p",null,"put(key, value): This method is used to add a key-value pair to the map. If the key already exists, its value will be updated with the new value."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'import java.util.HashMap;\nimport java.util.Map;\n\npublic class Main {\n    public static void main(String[] args) {\n        // Create a new HashMap\n        Map<String, Integer> myMap = new HashMap<>();\n\n        // Add key-value pairs to the map\n        myMap.put("Apple", 1);\n        myMap.put("Banana", 2);\n        myMap.put("Cherry", 3);\n\n        // Update the value for a key\n        myMap.put("Banana", 4);\n        System.out.println(myMap);\n    }\n}\n')),(0,r.kt)("p",null,"Output:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"{Apple=1, Banana=4, Cherry=3}\n")),(0,r.kt)("p",null,"get(key): This method is used to retrieve the value for a given key. If the key does not exist, it will return null."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'import java.util.HashMap;\nimport java.util.Map;\n\npublic class Main {\n    public static void main(String[] args) {\n        // Create a new HashMap\n        Map<String, Integer> myMap = new HashMap<>();\n\n        // Add key-value pairs to the map\n        myMap.put("Apple", 1);\n        myMap.put("Banana", 2);\n        myMap.put("Cherry", 3);\n\n        // Retrieve a value using a key\n        int value = myMap.get("Banana");\n        System.out.println(value);\n    }\n}\n')),(0,r.kt)("p",null,"Output:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"2\n")),(0,r.kt)("p",null,"remove(key): This method is used to remove a key-value pair from the map."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'import java.util.HashMap;\nimport java.util.Map;\n\npublic class Main {\n    public static void main(String[] args) {\n        // Create a new HashMap\n        Map<String, Integer> myMap = new HashMap<>();\n\n        // Add key-value pairs to the map\n        myMap.put("Apple", 1);\n        myMap.put("Banana", 2);\n        myMap.put("Cherry", 3);\n\n        // Remove a key-value pair\n        myMap.remove("Banana");\n        System.out.println(myMap);\n    }\n}\n')),(0,r.kt)("p",null,"Output:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"{Apple=1, Cherry=3}\n")),(0,r.kt)("p",null,"clear(): This method is used to remove all key-value pairs from the map."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'import java.util.HashMap;\nimport java.util.Map;\n\npublic class Main {\n    public static void main(String[] args) {\n        // Create a new HashMap\n        Map<String, Integer> myMap = new HashMap<>();\n\n        // Add key-value pairs to the map\n        myMap.put("Apple", 1);\n        myMap.put("Banana", 2);\n        myMap.put("Cherry", 3);\n        // Clear the map\n        myMap.clear();\n        System.out.println(myMap);\n    }\n}\n')),(0,r.kt)("p",null,"Output:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"{}\n")),(0,r.kt)("p",null,"size(): This method is used to get the number of key-value pairs in the map."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'import java.util.HashMap;\nimport java.util.Map;\n\npublic class Main {\n    public static void main(String[] args) {\n        // Create a new HashMap\n        Map<String, Integer> myMap = new HashMap<>();\n\n        // Add key-value pairs to the map\n        myMap.put("Apple", 1);\n        myMap.put("Banana", 2);\n        myMap.put("Cherry", 3);\n\n        // Get the size of the map\n        int size = myMap.size();\n        System.out.println(size);\n    }\n}\n')),(0,r.kt)("p",null,"Output:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"3\n")),(0,r.kt)("p",null,"keySet(): This method is used to get a set of all the keys in the map."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'import java.util.HashMap;\nimport java.util.Map;\nimport java.util.Set;\n\npublic class Main {\n    public static void main(String[] args) {\n        // Create a new HashMap\n        Map<String, Integer> myMap = new HashMap<>();\n\n        // Add key-value pairs to the map\n        myMap.put("Apple", 1);\n        myMap.put("Banana", 2);\n        myMap.put("Cherry", 3);\n\n        // Get the set of keys\n        Set<String> keys = myMap.keySet();\n        System.out.println(keys);\n    }\n}\n')),(0,r.kt)("p",null,"Output:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"[Apple, Banana, Cherry]\n")),(0,r.kt)("h2",{id:"performance-considerations-when-working-with-the-map-interface"},"Performance Considerations when working with the Map Interface"),(0,r.kt)("h3",{id:"time-complexity"},"Time Complexity"),(0,r.kt)("p",null,"The time complexity of the most common methods is generally O(1) for ",(0,r.kt)("inlineCode",{parentName:"p"},"HashMap")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"LinkedHashMap"),", which means they have constant time complexity and can handle large amounts of data efficiently. However, the time complexity of the TreeMap is O(log(n)) for most operations because it stores the data in a sorted tree structure."),(0,r.kt)("h3",{id:"memory-usage"},"Memory usage"),(0,r.kt)("p",null,"The memory usage of a map can depend on the number of key-value pairs stored in the map and the size of the keys and values. HashMap and LinkedHashMap have similar memory usage, but TreeMap uses more memory due to its sorted tree structure."),(0,r.kt)("p",null,"Example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'import java.util.HashMap;\nimport java.util.Map;\nimport java.util.Random;\n\npublic class Main {\n    public static void main(String[] args) {\n        int size = 1000000;\n        Random random = new Random();\n        // Create new HashMap\n        Map<Integer, Integer> hashMap = new HashMap<>();\n        //Measure time of inserting data to hashmap\n        long start = System.currentTimeMillis();\n        for (int i = 0; i < size; i++) {\n            hashMap.put(random.nextInt(), random.nextInt());\n        }\n        long end = System.currentTimeMillis();\n        System.out.println("Inserting data to HashMap takes:" + (end - start) + "ms");\n    }\n}\n')),(0,r.kt)("h1",{id:"additional-functionality-of-the-map-interface"},"Additional Functionality of the Map Interface"),(0,r.kt)("p",null,"The Map interface provides additional functionality beyond basic key-value pair manipulation. Some of the additional functionality includes:"),(0,r.kt)("p",null,"Obtaining a view of the keys or values: The keySet() and values() methods return a view of the keys and values in the map respectively."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'import java.util.HashMap;\nimport java.util.Map;\nimport java.util.Set;\n\npublic class Main {\n    public static void main(String[] args) {\n        // Create a new HashMap\n        Map<String, Integer> myMap = new HashMap<>();\n\n        // Add key-value pairs to the map\n        myMap.put("Apple", 1);\n        myMap.put("Banana", 2);\n        myMap.put("Cherry", 3);\n\n        // Get the set of keys\n        Set<String> keys = myMap.keySet();\n        System.out.println(keys);\n\n        // Get the collection of values\n        Collection<Integer> values = myMap.values();\n        System.out.println(values);\n    }\n}\n\n')),(0,r.kt)("p",null,"Output:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"[Apple, Banana, Cherry]\n[1, 2, 3]\n")),(0,r.kt)("p",null,"Obtaining a synchronized map: The Collections.synchronizedMap() method can be used to obtain a synchronized version of a map, which can be used to ensure thread-safety."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"import java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class Main {\n    public static void main(String[] args) {\n        // Create a new HashMap\n        Map<String, Integer> myMap = new HashMap<>();\n        //create a synchronized map\n        Map<String, Integer> synMap = Collections.synchronizedMap(myMap);\n    }\n}\n")))}u.isMDXComponent=!0}}]);