"use strict";(self.webpackChunkjavabrains_bootcamp=self.webpackChunkjavabrains_bootcamp||[]).push([[8092],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>u});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=a.createContext({}),d=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},p=function(e){var t=d(e.components);return a.createElement(l.Provider,{value:t},e.children)},m="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),m=d(n),h=i,u=m["".concat(l,".").concat(h)]||m[h]||c[h]||o;return n?a.createElement(u,r(r({ref:t},p),{},{components:n})):a.createElement(u,r({ref:t},p))}));function u(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,r=new Array(o);r[0]=h;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[m]="string"==typeof e?e:i,r[1]=s;for(var d=2;d<o;d++)r[d]=n[d];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},2438:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>m,frontMatter:()=>o,metadata:()=>s,toc:()=>d});var a=n(7462),i=(n(7294),n(3905));const o={},r="The Set interface",s={unversionedId:"java-backend-bootcamp/java-collections/the-set-interface",id:"java-backend-bootcamp/java-collections/the-set-interface",title:"The Set interface",description:"Introduction",source:"@site/docs/java-backend-bootcamp/java-collections/the-set-interface.md",sourceDirName:"java-backend-bootcamp/java-collections",slug:"/java-backend-bootcamp/java-collections/the-set-interface",permalink:"/java-backend-bootcamp/docs/java-backend-bootcamp/java-collections/the-set-interface",draft:!1,editUrl:"https://github.com/koushikkothagal/java-backend-bootcamp/tree/main/website/docs/java-backend-bootcamp/java-collections/the-set-interface.md",tags:[],version:"current",frontMatter:{},sidebar:"javaBackendBootcamp",previous:{title:"Comparable and Comparator",permalink:"/java-backend-bootcamp/docs/java-backend-bootcamp/java-collections/comparable-and-comparator"},next:{title:"The Map interface",permalink:"/java-backend-bootcamp/docs/java-backend-bootcamp/java-collections/the-map-interface"}},l={},d=[{value:"Introduction",id:"introduction",level:2},{value:"Implementations of the Set Interface",id:"implementations-of-the-set-interface",level:2},{value:"HashSet",id:"hashset",level:3},{value:"LinkedHashSet",id:"linkedhashset",level:3},{value:"TreeSet",id:"treeset",level:3},{value:"Common Methods of the Set Interface",id:"common-methods-of-the-set-interface",level:2},{value:"Set Interface and Generics",id:"set-interface-and-generics",level:2},{value:"Set Interface and Autoboxing",id:"set-interface-and-autoboxing",level:2},{value:"CopyOnWriteArraySet",id:"copyonwritearrayset",level:2},{value:"Performance Considerations",id:"performance-considerations",level:2},{value:"Time Complexity",id:"time-complexity",level:3},{value:"Memory Usage",id:"memory-usage",level:3},{value:"Additional Functionality of the Set Interface: Set Operations",id:"additional-functionality-of-the-set-interface-set-operations",level:2},{value:"Union",id:"union",level:3},{value:"Intersection",id:"intersection",level:3},{value:"Difference",id:"difference",level:3}],p={toc:d};function m(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"the-set-interface"},"The Set interface"),(0,i.kt)("h2",{id:"introduction"},"Introduction"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"Set")," interface in Java is a part of the Java Collection Framework and it extends the ",(0,i.kt)("inlineCode",{parentName:"p"},"Collection")," interface. It is used to represent a collection of unique elements, meaning that it does not allow duplicate elements. The ",(0,i.kt)("inlineCode",{parentName:"p"},"Set")," interface provides a set of methods for adding, removing, and searching for elements in the set."),(0,i.kt)("p",null,"One of the main characteristics of the ",(0,i.kt)("inlineCode",{parentName:"p"},"Set")," interface is that it does not maintain the insertion order of elements, unlike the List interface. This means that the order of elements in a ",(0,i.kt)("inlineCode",{parentName:"p"},"Set")," may change when elements are added or removed, and elements may be returned in a different order than they were added."),(0,i.kt)("p",null,"Here's an example of creating a ",(0,i.kt)("inlineCode",{parentName:"p"},"Set")," of strings:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},'import java.util.HashSet;\nimport java.util.Set;\n\npublic class SetExample {\n    public static void main(String[] args) {\n        // creating a set of strings\n        Set<String> fruits = new HashSet<>();\n\n        // adding elements to the set\n        fruits.add("apple");\n        fruits.add("banana");\n        fruits.add("orange");\n\n        // adding a duplicate element\n        fruits.add("apple"); // Does not change the Set\n\n        // printing the set\n        System.out.println(fruits);\n    }\n}\n')),(0,i.kt)("p",null,"In this example, we created a ",(0,i.kt)("inlineCode",{parentName:"p"},"Set"),' of strings and added three elements to it: "apple", "banana", and "orange". We also added a duplicate element "apple" to the set, but the set only contains one "apple" as the set does not allow duplicate elements.'),(0,i.kt)("p",null,"The Set interface has many implementations such as ",(0,i.kt)("inlineCode",{parentName:"p"},"HashSet"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"LinkedHashSet"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"TreeSet"),", which have different characteristics and performance."),(0,i.kt)("h2",{id:"implementations-of-the-set-interface"},"Implementations of the Set Interface"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"Set")," interface in Java has several implementations, each with its own characteristics and performance. The most commonly used implementations are:"),(0,i.kt)("h3",{id:"hashset"},"HashSet"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"HashSet")," class is the most commonly used implementation of the ",(0,i.kt)("inlineCode",{parentName:"p"},"Set")," interface. It uses a hash table for storage and provides constant time performance for the basic operations such as add(), remove(), contains(), and size(). A hash table is a data structure that uses a hash function to map keys to indices in an array, called a bucket. The main advantage of HashSet is that it provides fast performance for the basic operations, but it does not maintain the insertion order of elements.\nHere's an example of creating a ",(0,i.kt)("inlineCode",{parentName:"p"},"HashSet")," of strings:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},'import java.util.HashSet;\nimport java.util.Set;\n\npublic class HashSetExample {\n    public static void main(String[] args) {\n        // creating a HashSet of strings\n        Set<String> fruits = new HashSet<>();\n\n        // adding elements to the set\n        fruits.add("apple");\n        fruits.add("banana");\n        fruits.add("orange");\n\n        // printing the set\n        System.out.println(fruits);\n    }\n}\n')),(0,i.kt)("h3",{id:"linkedhashset"},"LinkedHashSet"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"LinkedHashSet")," class is an implementation of the ",(0,i.kt)("inlineCode",{parentName:"p"},"Set")," interface that extends ",(0,i.kt)("inlineCode",{parentName:"p"},"HashSet"),". It maintains the insertion order of elements and uses a doubly-linked list to link the elements together. This means that elements are returned in the order they were inserted. The main advantage of ",(0,i.kt)("inlineCode",{parentName:"p"},"LinkedHashSet")," is that it maintains the insertion order of elements, but it has a slightly higher memory overhead than ",(0,i.kt)("inlineCode",{parentName:"p"},"HashSet"),"."),(0,i.kt)("p",null,"Here's an example of creating a ",(0,i.kt)("inlineCode",{parentName:"p"},"LinkedHashSet")," of strings:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},'import java.util.LinkedHashSet;\nimport java.util.Set;\n\npublic class LinkedHashSetExample {\n    public static void main(String[] args) {\n        // creating a LinkedHashSet of strings\n        Set<String> fruits = new LinkedHashSet<>();\n\n        // adding elements to the set\n        fruits.add("apple");\n        fruits.add("banana");\n        fruits.add("orange");\n\n        // printing the set\n        System.out.println(fruits); //[apple, banana, orange]\n    }\n}\n')),(0,i.kt)("h3",{id:"treeset"},"TreeSet"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"TreeSet")," class is an implementation of the Set interface that provides fast performance for the basic operations and it maintains the natural ordering of elements, or elements can be ordered by a ",(0,i.kt)("inlineCode",{parentName:"p"},"Comparator")," (if provided at set creation time). The ",(0,i.kt)("inlineCode",{parentName:"p"},"TreeSet")," class implements the ",(0,i.kt)("inlineCode",{parentName:"p"},"SortedSet")," interface, which provides a total ordering on its elements."),(0,i.kt)("p",null,"Here's an example of creating a TreeSet of strings:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},'import java.util.TreeSet;\nimport java.util.Set;\n\npublic class TreeSetExample {\n    public static void main(String[] args) {\n        // creating a TreeSet of strings\n        Set<String> fruits = new TreeSet<>();\n\n        // adding elements to the set\n        fruits.add("orange");\n        fruits.add("banana");\n        fruits.add("apple");\n\n        // printing the set\n        System.out.println(fruits); // [apple, banana, orange]\n    }\n}\n')),(0,i.kt)("p",null,"When choosing which implementation of the ",(0,i.kt)("inlineCode",{parentName:"p"},"Set")," interface to use, consider the following:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"If you need fast performance for the basic operations and do not need to maintain the insertion order of elements, use ",(0,i.kt)("inlineCode",{parentName:"li"},"HashSet"),"."),(0,i.kt)("li",{parentName:"ul"},"If you need to maintain the insertion order of elements, use ",(0,i.kt)("inlineCode",{parentName:"li"},"LinkedHashSet"),"."),(0,i.kt)("li",{parentName:"ul"},"If you need to maintain the natural ordering of elements or order elements by a comparator and need range operations and navigation, use ",(0,i.kt)("inlineCode",{parentName:"li"},"TreeSet"),".")),(0,i.kt)("h2",{id:"common-methods-of-the-set-interface"},"Common Methods of the Set Interface"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"Set")," interface in Java provides a set of methods for adding, removing, and searching for elements in the set. The most commonly used methods are:"),(0,i.kt)("p",null,"add(E e): This method is used to add an element to the set. If the set already contains the element, the method does not add the element and returns false. Here's an example of using the add() method:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},'import java.util.HashSet;\nimport java.util.Set;\n\npublic class AddMethodExample {\n    public static void main(String[] args) {\n        Set<String> fruits = new HashSet<>();\n        fruits.add("apple");\n        fruits.add("banana");\n        fruits.add("orange");\n\n        // adding a new element\n        boolean added = fruits.add("mango");\n        System.out.println("Mango added: " + added);\n\n        // adding a duplicate element\n        added = fruits.add("apple");\n        System.out.println("Apple added: " + added); // false\n\n        // printing the set\n        System.out.println(fruits);\n    }\n}\n')),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"add()")," method returns true when an element is added successfully and returns false when the element is already in the set."),(0,i.kt)("p",null,"remove(Object o): This method is used to remove an element from the set. If the set does not contain the element, the method does not remove the element and returns false. Here's an example of using the remove() method:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},'import java.util.HashSet;\nimport java.util.Set;\n\npublic class RemoveMethodExample {\n    public static void main(String[] args) {\n        Set<String> fruits = new HashSet<>();\n        fruits.add("apple");\n        fruits.add("banana");\n        fruits.add("orange");\n\n        // removing an element\n        boolean removed = fruits.remove("banana");\n        System.out.println("Banana removed: " + removed);\n\n        // removing a non-existing element\n        removed = fruits.remove("mango");\n        System.out.println("Mango removed: " + removed);\n\n        // printing the set\n        System.out.println(fruits);\n    }\n}\n')),(0,i.kt)("p",null,"The remove() method returns true when an element is removed successfully and returns false when the element is not in the set."),(0,i.kt)("p",null,"clear(): This method is used to remove all elements from the set. Here's an example of using the clear() method:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},'import java.util.HashSet;\nimport java.util.Set;\n\npublic class ClearMethodExample {\n    public static void main(String[] args) {\n        Set<String> fruits = new HashSet<>();\n        fruits.add("apple");\n        fruits.add("banana");\n        fruits.add("orange");\n\n        // printing the set before clearing\n        System.out.println("Before clearing: " + fruits);\n\n        // clearing the set\n        fruits.clear();\n\n        // printing the set after clearing\n        System.out.println("After clearing: " + fruits); // Empty set\n    }\n}\n')),(0,i.kt)("p",null,"contains(Object o): This method is used to check if the set contains a specific element. It returns true if the element is in the set and false otherwise."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},'import java.util.HashSet;\nimport java.util.Set;\n\npublic class ContainsMethodExample {\n    public static void main(String[] args) {\n        Set<String> fruits = new HashSet<>();\n        fruits.add("apple");\n        fruits.add("banana");\n        fruits.add("orange");\n\n        // checking if the set contains an element\n        boolean contains = fruits.contains("banana");\n        System.out.println("Contains banana: " + contains);\n\n        contains = fruits.contains("mango");\n        System.out.println("Contains mango: " + contains);\n    }\n}\n')),(0,i.kt)("p",null,"size(): This method is used to get the number of elements in the set. It returns an integer representing the number of elements in the set."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},'import java.util.HashSet;\nimport java.util.Set;\n\npublic class SizeMethodExample {\n    public static void main(String[] args) {\n        Set<String> fruits = new HashSet<>();\n        fruits.add("apple");\n        fruits.add("banana");\n        fruits.add("orange");\n\n        // getting the size of the set\n        int size = fruits.size();\n        System.out.println("Size of the set: " + size);\n    }\n}\n')),(0,i.kt)("p",null,"In addition to the above-mentioned methods, the Set interface also provides an iterator() method, which returns an iterator over the elements in the set. The Iterator interface provides methods for iterating over a collection, such as hasNext() and next() methods. Here's an example of using the iterator() method:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},'import java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.Set;\n\npublic class IteratorExample {\n    public static void main(String[] args) {\n        Set<String> fruits = new HashSet<>();\n        fruits.add("apple");\n        fruits.add("banana");\n        fruits.add("orange");\n\n        // getting an iterator over the set\n        Iterator<String> iterator = fruits.iterator();\n\n        // iterating over the set\n        while (iterator.hasNext()) {\n            String fruit = iterator.next();\n            System.out.println(fruit);\n        }\n    }\n}\n\n')),(0,i.kt)("p",null,"You can use the hasNext() method to check if there are more elements to iterate over, and the next() method to get the next element in the set."),(0,i.kt)("h2",{id:"set-interface-and-generics"},"Set Interface and Generics"),(0,i.kt)("p",null,"The Set interface in Java can be used with generics to create a set of a specific type of object. Generics provide a way to specify the type of elements in a collection. By using generics, we can ensure that a collection contains elements of a specific type, and avoid runtime type casting errors."),(0,i.kt)("p",null,"Here's an example of creating a Set of strings using generics:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},'import java.util.HashSet;\nimport java.util.Set;\n\npublic class SetWithGenericsExample {\n    public static void main(String[] args) {\n        // creating a Set of strings using generics\n        Set<String> fruits = new HashSet<>();\n\n        // adding elements to the set\n        fruits.add("apple");\n        fruits.add("banana");\n        fruits.add("orange");\n\n        // printing the set\n        System.out.println(fruits);\n    }\n}\n')),(0,i.kt)("p",null,"We can now be sure that the set only contains strings and not any other types of objects."),(0,i.kt)("p",null,"It's also possible to create a ",(0,i.kt)("inlineCode",{parentName:"p"},"Set")," of custom objects using generics. Here's an example of creating a ",(0,i.kt)("inlineCode",{parentName:"p"},"Set")," of ",(0,i.kt)("inlineCode",{parentName:"p"},"Employee")," objects:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},'import java.util.HashSet;\nimport java.util.Set;\n\nclass Employee {\n    private String name;\n    private int age;\n\n    public Employee(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    // getters and setters ...\n\n}\n\npublic class SetWithCustomObjectsExample {\n    public static void main(String[] args) {\n        // creating a Set of Employee objects using generics\n        Set<Employee> employees = new HashSet<>();\n\n        // adding elements to the set\n        employees.add(new Employee("John", 25));\n        employees.add(new Employee("Jane", 30));\n        employees.add(new Employee("Mike", 35));\n\n        // printing the set\n        System.out.println(employees);\n\n    }\n}\n')),(0,i.kt)("p",null,"In addition to creating a Set of custom objects, it's also possible to create a Set of custom objects that implements a specific interface or extends a specific class using generics. Here's an example of creating a Set of Employee objects that implement the Comparable interface:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},'import java.util.TreeSet;\nimport java.util.Set;\n\nclass Employee implements Comparable<Employee> {\n    private String name;\n    private int age;\n\n    public Employee(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    @Override\n    public String toString() {\n        return "Employee{name=\'" + name + "\', age=" + age + "}";\n    }\n\n    @Override\n    public int compareTo(Employee other) {\n        return this.name.compareTo(other.name);\n    }\n}\n\npublic class SetWithCustomObjectsAndComparableExample {\n    public static void main(String[] args) {\n        // creating a Set of Employee objects that implement Comparable using generics\n        Set<Employee> employees = new TreeSet<>();\n\n        // adding elements to the set\n        employees.add(new Employee("John", 25));\n        employees.add(new Employee("Jane", 30));\n        employees.add(new Employee("Mike", 35));\n\n        // printing the set\n        System.out.println(employees);\n    }\n}\n')),(0,i.kt)("p",null,"In this example, we implemented the Comparable interface in the Employee class and overridden the compareTo method that compares the name of the employees. We then created a Set of Employee objects that implement the Comparable interface using generics and added three Employee objects to the set. The set is now sorted by the name of the employees."),(0,i.kt)("h2",{id:"set-interface-and-autoboxing"},"Set Interface and Autoboxing"),(0,i.kt)("p",null,"The Set interface in Java can be used with autoboxing to store primitive data types. Autoboxing is the automatic conversion of a primitive data type to its corresponding wrapper class. For example, autoboxing converts an int to an Integer, a boolean to a Boolean, and so on."),(0,i.kt)("p",null,"Here's an example of creating a Set of integers using autoboxing:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},"import java.util.HashSet;\nimport java.util.Set;\n\npublic class SetWithAutoboxingAndForLoopExample {\n    public static void main(String[] args) {\n        // creating a Set of integers using autoboxing\n        Set<Integer> numbers = new HashSet<>();\n\n        // adding elements to the set using a for loop\n        for (int i = 1; i <= 5; i++) {\n            numbers.add(i);\n        }\n        // printing the set\n        System.out.println(numbers);\n    }\n}\n")),(0,i.kt)("p",null,"In this example, we created a Set of integers using autoboxing and added elements to the set using a for loop. The int values are automatically converted to Integer objects by autoboxing inside the for loop."),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"When using autoboxing with a Set, you can't use the ",(0,i.kt)("inlineCode",{parentName:"p"},"==")," operator to compare elements in the set because ",(0,i.kt)("inlineCode",{parentName:"p"},"==")," compares the references, not the values. Instead, you should use the .equals() method to compare the values of the elements in the set.")),(0,i.kt)("h2",{id:"copyonwritearrayset"},"CopyOnWriteArraySet"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"CopyOnWriteArraySet")," is a thread-safe variant of the ",(0,i.kt)("inlineCode",{parentName:"p"},"Set")," interface in Java. It is a concurrent collection class that uses a copy-on-write strategy, which means that all modifications to the set are made on a copy of the underlying array. This ensures that multiple threads can read the set simultaneously without the need for locks, while still allowing for safe and efficient modification. The ",(0,i.kt)("inlineCode",{parentName:"p"},"CopyOnWriteArraySet")," is backed by a ",(0,i.kt)("inlineCode",{parentName:"p"},"CopyOnWriteArrayList")," which provides a thread-safe way to manipulate the set. This makes ",(0,i.kt)("inlineCode",{parentName:"p"},"CopyOnWriteArraySet")," well-suited for situations where many threads will be reading the set, but relatively few will be modifying it. However, because the array is copied on every modification, this class is less efficient than a standard HashSet when modifications are frequent."),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"Remember, it's ",(0,i.kt)("inlineCode",{parentName:"p"},"CopyOnWriteArraySet"),", not ",(0,i.kt)("inlineCode",{parentName:"p"},"CopyOnWriteSet"),"!")),(0,i.kt)("h2",{id:"performance-considerations"},"Performance Considerations"),(0,i.kt)("h3",{id:"time-complexity"},"Time Complexity"),(0,i.kt)("p",null,"The add method has a time complexity of O(1) on average for HashSet and LinkedHashSet, and O(log n) for TreeSet.\nThe remove method has a time complexity of O(1) on average for HashSet and LinkedHashSet, and O(log n) for TreeSet.\nThe contains method has a time complexity of O(1) on average for HashSet and LinkedHashSet, and O(log n) for TreeSet."),(0,i.kt)("h3",{id:"memory-usage"},"Memory Usage"),(0,i.kt)("p",null,"HashSet and LinkedHashSet use internal HashMap implementation. LinkedHashSet also maintains a LinkedList of it's elements so require extra space to maintain adjacent element references"),(0,i.kt)("h2",{id:"additional-functionality-of-the-set-interface-set-operations"},"Additional Functionality of the Set Interface: Set Operations"),(0,i.kt)("p",null,"The Set interface in Java provides additional functionality for performing set operations such as union, intersection, and difference. Set operations are used to manipulate and compare sets of elements. In this section, we'll discuss how to perform these operations using the Set interface."),(0,i.kt)("h3",{id:"union"},"Union"),(0,i.kt)("p",null,"The union of two sets is a set that contains all the elements from both sets. In Java, the union can be performed using the ",(0,i.kt)("inlineCode",{parentName:"p"},"addAll")," method of the ",(0,i.kt)("inlineCode",{parentName:"p"},"Set")," interface. Here's an example of performing the union of two sets:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},'import java.util.HashSet;\nimport java.util.Set;\n\npublic class SetUnionExample {\n    public static void main(String[] args) {\n        Set<Integer> set1 = new HashSet<>();\n        set1.add(1);\n        set1.add(2);\n        set1.add(3);\n        set1.add(4);\n        System.out.println("Set 1: " + set1);\n\n        Set<Integer> set2 = new HashSet<>();\n        set2.add(3);\n        set2.add(4);\n        set2.add(5);\n        set2.add(6);\n        System.out.println("Set 2: " + set2);\n\n        set1.addAll(set2);\n        System.out.println("Union: " + set1);\n    }\n}\n')),(0,i.kt)("p",null,"The union of the two sets contains all the elements from both sets: {1, 2, 3, 4, 5, 6}."),(0,i.kt)("h3",{id:"intersection"},"Intersection"),(0,i.kt)("p",null,"The intersection of two sets is a set that contains only the elements that are common to both sets. In Java, the intersection can be performed using the ",(0,i.kt)("inlineCode",{parentName:"p"},"retainAll")," method of the ",(0,i.kt)("inlineCode",{parentName:"p"},"Set")," interface. Here's an example of performing the intersection of two sets:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},'import java.util.HashSet;\nimport java.util.Set;\n\npublic class SetIntersectionExample {\n    public static void main(String[] args) {\n        Set<Integer> set1 = new HashSet<>();\n        set1.add(1);\n        set1.add(2);\n        set1.add(3);\n        set1.add(4);\n        System.out.println("Set 1: " + set1);\n\n        Set<Integer> set2 = new HashSet<>();\n        set2.add(3);\n        set2.add(4);\n        set2.add(5);\n        set2.add(6);\n        System.out.println("Set 2: " + set2);\n\n        set1.retainAll(set2);\n        System.out.println("Intersection: " + set1);\n    }\n}\n\n')),(0,i.kt)("p",null,"The intersection of the two sets contains only the elements that are common to both sets: {3, 4}."),(0,i.kt)("h3",{id:"difference"},"Difference"),(0,i.kt)("p",null,"The difference of two sets is a set that contains the elements that are present in the first set but not in the second set. In Java, the difference can be performed using the ",(0,i.kt)("inlineCode",{parentName:"p"},"removeAll")," method of the Set interface. Here's an example of performing the difference of two sets:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},'import java.util.HashSet;\nimport java.util.Set;\n\npublic class SetDifferenceExample {\n    public static void main(String[] args) {\n        Set<Integer> set1 = new HashSet<>();\n        set1.add(1);\n        set1.add(2);\n        set1.add(3);\n        set1.add(4);\n        System.out.println("Set 1: " + set1);\n\n        Set<Integer> set2 = new HashSet<>();\n        set2.add(3);\n        set2.add(4);\n        set2.add(5);\n        set2.add(6);\n        System.out.println("Set 2: " + set2);\n\n        set1.removeAll(set2);\n        System.out.println("Difference: " + set1);\n    }\n}\n')),(0,i.kt)("p",null,"The difference of the two sets contains the elements that are present in the first set but not in the second set: {1, 2}."),(0,i.kt)("p",null,"::note\nThese set operations will modify the original set and store the result in it. If you want to perform set operations without modifying the original set, you'll need to create a copy of the original set and perform the operations on the copy.\n:::"))}m.isMDXComponent=!0}}]);