"use strict";(self.webpackChunkjavabrains_bootcamp=self.webpackChunkjavabrains_bootcamp||[]).push([[8827],{3905:(e,a,t)=>{t.d(a,{Zo:()=>u,kt:()=>f});var n=t(7294);function o(e,a,t){return a in e?Object.defineProperty(e,a,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[a]=t,e}function r(e,a){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);a&&(n=n.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),t.push.apply(t,n)}return t}function i(e){for(var a=1;a<arguments.length;a++){var t=null!=arguments[a]?arguments[a]:{};a%2?r(Object(t),!0).forEach((function(a){o(e,a,t[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(t,a))}))}return e}function c(e,a){if(null==e)return{};var t,n,o=function(e,a){if(null==e)return{};var t,n,o={},r=Object.keys(e);for(n=0;n<r.length;n++)t=r[n],a.indexOf(t)>=0||(o[t]=e[t]);return o}(e,a);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)t=r[n],a.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var l=n.createContext({}),s=function(e){var a=n.useContext(l),t=a;return e&&(t="function"==typeof e?e(a):i(i({},a),e)),t},u=function(e){var a=s(e.components);return n.createElement(l.Provider,{value:a},e.children)},m="mdxType",p={inlineCode:"code",wrapper:function(e){var a=e.children;return n.createElement(n.Fragment,{},a)}},d=n.forwardRef((function(e,a){var t=e.components,o=e.mdxType,r=e.originalType,l=e.parentName,u=c(e,["components","mdxType","originalType","parentName"]),m=s(t),d=o,f=m["".concat(l,".").concat(d)]||m[d]||p[d]||r;return t?n.createElement(f,i(i({ref:a},u),{},{components:t})):n.createElement(f,i({ref:a},u))}));function f(e,a){var t=arguments,o=a&&a.mdxType;if("string"==typeof e||o){var r=t.length,i=new Array(r);i[0]=d;var c={};for(var l in a)hasOwnProperty.call(a,l)&&(c[l]=a[l]);c.originalType=e,c[m]="string"==typeof e?e:o,i[1]=c;for(var s=2;s<r;s++)i[s]=t[s];return n.createElement.apply(null,i)}return n.createElement.apply(null,t)}d.displayName="MDXCreateElement"},5571:(e,a,t)=>{t.r(a),t.d(a,{assets:()=>l,contentTitle:()=>i,default:()=>m,frontMatter:()=>r,metadata:()=>c,toc:()=>s});var n=t(7462),o=(t(7294),t(3905));const r={},i="Custom Functional Interfaces",c={unversionedId:"java-backend-bootcamp/lambdas-and-streams/custom-interfaces",id:"java-backend-bootcamp/lambdas-and-streams/custom-interfaces",title:"Custom Functional Interfaces",description:"A functional interface is an interface that contains exactly one abstract method. In Java 8, several functional interfaces were added to the java.util.function package, such as Predicate, Consumer, and Function. However, in certain situations, you may need to create your own functional interface. In this section, we will cover how to create custom functional interfaces and provide examples of their use.",source:"@site/docs/java-backend-bootcamp/lambdas-and-streams/custom-interfaces.md",sourceDirName:"java-backend-bootcamp/lambdas-and-streams",slug:"/java-backend-bootcamp/lambdas-and-streams/custom-interfaces",permalink:"/java-backend-bootcamp/docs/java-backend-bootcamp/lambdas-and-streams/custom-interfaces",draft:!1,editUrl:"https://github.com/koushikkothagal/java-backend-bootcamp/tree/main/website/docs/java-backend-bootcamp/lambdas-and-streams/custom-interfaces.md",tags:[],version:"current",frontMatter:{},sidebar:"javaBackendBootcamp",previous:{title:"Lambda Expressions",permalink:"/java-backend-bootcamp/docs/java-backend-bootcamp/lambdas-and-streams/lambda-expressions"},next:{title:"Best Practices",permalink:"/java-backend-bootcamp/docs/java-backend-bootcamp/lambdas-and-streams/best-practices"}},l={},s=[{value:"Creating a Custom Functional Interface",id:"creating-a-custom-functional-interface",level:2},{value:"Using a Custom Functional Interface",id:"using-a-custom-functional-interface",level:2},{value:"Examples",id:"examples",level:2}],u={toc:s};function m(e){let{components:a,...t}=e;return(0,o.kt)("wrapper",(0,n.Z)({},u,t,{components:a,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"custom-functional-interfaces"},"Custom Functional Interfaces"),(0,o.kt)("p",null,"A functional interface is an interface that contains exactly one abstract method. In Java 8, several functional interfaces were added to the java.util.function package, such as ",(0,o.kt)("inlineCode",{parentName:"p"},"Predicate"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"Consumer"),", and ",(0,o.kt)("inlineCode",{parentName:"p"},"Function"),". However, in certain situations, you may need to create your own functional interface. In this section, we will cover how to create custom functional interfaces and provide examples of their use."),(0,o.kt)("h2",{id:"creating-a-custom-functional-interface"},"Creating a Custom Functional Interface"),(0,o.kt)("p",null,"Creating a custom functional interface is simple. First, define an interface with a single abstract method. Next, annotate the interface with the ",(0,o.kt)("inlineCode",{parentName:"p"},"@FunctionalInterface")," annotation. This annotation is optional, but it provides an additional level of type safety by ensuring that the interface can only be implemented by exactly one abstract method."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},"@FunctionalInterface\ninterface MyFunctionalInterface {\n    void doSomething();\n}\n")),(0,o.kt)("p",null,"You can also add default and static methods to the functional interface, but they do not count towards the single abstract method requirement."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},"@FunctionalInterface\ninterface MyFunctionalInterface {\n    void doSomething();\n    default void doSomethingElse() {\n        // implementation\n    }\n    static void doAnotherThing() {\n        // implementation\n    }\n}\n")),(0,o.kt)("h2",{id:"using-a-custom-functional-interface"},"Using a Custom Functional Interface"),(0,o.kt)("p",null,"Once you have defined a custom functional interface, you can implement it using a lambda expression or a method reference."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},'MyFunctionalInterface myFunction = () -> System.out.println("Hello World!");\nmyFunction.doSomething();\n\n// or\n\nMyFunctionalInterface myFunction = System.out::println;\nmyFunction.doSomething();\n')),(0,o.kt)("p",null,"You can also use the interface as a type for method arguments or return values."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},'class MyClass {\n    public void doSomething(MyFunctionalInterface myFunction) {\n        myFunction.doSomething();\n    }\n}\n\nMyClass myObject = new MyClass();\nmyObject.doSomething(() -> System.out.println("Hello World!"));\n')),(0,o.kt)("h2",{id:"examples"},"Examples"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Creating a functional interface for a comparison operation:")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},"@FunctionalInterface\ninterface Comparator<T> {\n    int compare(T o1, T o2);\n}\n")),(0,o.kt)("ol",{start:2},(0,o.kt)("li",{parentName:"ol"},"Creating a functional interface for a mathematical operation:")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},"@FunctionalInterface\ninterface MathOperation {\n    int operation(int a, int b);\n}\n")),(0,o.kt)("p",null,"In conclusion, creating a custom functional interface is a simple process that can add an additional level of type safety to your code. They are useful for situations where the pre-existing functional interfaces in the java.util.function package do not meet your needs."),(0,o.kt)("admonition",{type:"note"},(0,o.kt)("p",{parentName:"admonition"},"You can also use these custom functional interface as a type for method arguments or return values.")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},"class Calculator {\n    public int calculate(MathOperation mathOperation, int a, int b) {\n        return mathOperation.operation(a, b);\n    }\n}\n")),(0,o.kt)("p",null,"You can pass lambda expressions to the method, for example:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},"Calculator calculator = new Calculator();\nint result = calculator.calculate((a, b) -> a + b, 5, 7);\n")),(0,o.kt)("p",null,"This way you can pass any mathematical operation you want to perform on the example provided above,"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},'Calculator calculator = new Calculator();\n\nMathOperation addition = (a, b) -> a + b;\nMathOperation subtraction = (a, b) -> a - b;\nMathOperation multiplication = (a, b) -> a * b;\nMathOperation division = (a, b) -> a / b;\n\nint result1 = calculator.calculate(addition, 5, 7);\nint result2 = calculator.calculate(subtraction, 5, 7);\nint result3 = calculator.calculate(multiplication, 5, 7);\nint result4 = calculator.calculate(division, 5, 7);\n\nSystem.out.println("Addition: " + result1);\nSystem.out.println("Subtraction: " + result2);\nSystem.out.println("Multiplication: " + result3);\nSystem.out.println("Division: " + result4);\n')),(0,o.kt)("p",null,"As you can see, the custom functional interface allows us to pass any mathematical operation we want to perform as a method argument. This allows for more flexibility and modularity in our code, as we can easily swap out different operations without changing the rest of our code."),(0,o.kt)("admonition",{type:"note"},(0,o.kt)("p",{parentName:"admonition"},"Functional interfaces are useful when working with streams in Java 8. The Stream API has several methods that take functional interfaces as arguments, such as filter(), map(), and reduce(). By creating custom functional interfaces, you can pass your own logic to these methods and manipulate streams in a more powerful and efficient way.")),(0,o.kt)("p",null,"In summary, creating custom functional interfaces can be a powerful tool for writing more flexible, modular and efficient code. With functional interfaces, you can create reusable blocks of code that can be passed around as method arguments, making your code more modular and easier to test."))}m.isMDXComponent=!0}}]);