"use strict";(self.webpackChunkjavabrains_bootcamp=self.webpackChunkjavabrains_bootcamp||[]).push([[4050],{3905:(e,t,a)=>{a.d(t,{Zo:()=>p,kt:()=>u});var n=a(7294);function o(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){o(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function c(e,t){if(null==e)return{};var a,n,o=function(e,t){if(null==e)return{};var a,n,o={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(o[a]=e[a]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(o[a]=e[a])}return o}var l=n.createContext({}),s=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},p=function(e){var t=s(e.components);return n.createElement(l.Provider,{value:t},e.children)},h="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},d=n.forwardRef((function(e,t){var a=e.components,o=e.mdxType,r=e.originalType,l=e.parentName,p=c(e,["components","mdxType","originalType","parentName"]),h=s(a),d=o,u=h["".concat(l,".").concat(d)]||h[d]||m[d]||r;return a?n.createElement(u,i(i({ref:t},p),{},{components:a})):n.createElement(u,i({ref:t},p))}));function u(e,t){var a=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=a.length,i=new Array(r);i[0]=d;var c={};for(var l in t)hasOwnProperty.call(t,l)&&(c[l]=t[l]);c.originalType=e,c[h]="string"==typeof e?e:o,i[1]=c;for(var s=2;s<r;s++)i[s]=a[s];return n.createElement.apply(null,i)}return n.createElement.apply(null,a)}d.displayName="MDXCreateElement"},2200:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>h,frontMatter:()=>r,metadata:()=>c,toc:()=>s});var n=a(7462),o=(a(7294),a(3905));const r={},i="Generalization with Interfaces",c={unversionedId:"java-backend-bootcamp/java-collections/generalization-with-interfaces",id:"java-backend-bootcamp/java-collections/generalization-with-interfaces",title:"Generalization with Interfaces",description:"In Object Oriented Programming, interfaces are a way to define a contract for a group of related classes. An interface defines a set of method signatures, but does not provide an implementation for those methods. Classes that implement the interface must provide an implementation for all of the methods defined in the interface.",source:"@site/docs/java-backend-bootcamp/java-collections/generalization-with-interfaces.md",sourceDirName:"java-backend-bootcamp/java-collections",slug:"/java-backend-bootcamp/java-collections/generalization-with-interfaces",permalink:"/java-backend-bootcamp/docs/java-backend-bootcamp/java-collections/generalization-with-interfaces",draft:!1,editUrl:"https://github.com/koushikkothagal/java-backend-bootcamp/tree/main/website/docs/java-backend-bootcamp/java-collections/generalization-with-interfaces.md",tags:[],version:"current",frontMatter:{},sidebar:"javaBackendBootcamp",previous:{title:"Introduction to Collections",permalink:"/java-backend-bootcamp/docs/java-backend-bootcamp/java-collections/introduction"},next:{title:"Object equality and hashcode",permalink:"/java-backend-bootcamp/docs/java-backend-bootcamp/java-collections/object-equality-and-hashcode"}},l={},s=[],p={toc:s};function h(e){let{components:t,...a}=e;return(0,o.kt)("wrapper",(0,n.Z)({},p,a,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"generalization-with-interfaces"},"Generalization with Interfaces"),(0,o.kt)("p",null,"In Object Oriented Programming, interfaces are a way to define a contract for a group of related classes. An interface defines a set of method signatures, but does not provide an implementation for those methods. Classes that implement the interface must provide an implementation for all of the methods defined in the interface."),(0,o.kt)("p",null,"Consider the interface below:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},"interface Shape {\n    double getArea();\n    double getPerimeter();\n}\n")),(0,o.kt)("p",null,"Classes that implement the interface must provide an implementation for all of the methods defined in the interface. For example, we could have a ",(0,o.kt)("inlineCode",{parentName:"p"},"Rectangle")," class that implements the ",(0,o.kt)("inlineCode",{parentName:"p"},"Shape")," interface:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},"class Rectangle implements Shape {\n    private double width;\n    private double height;\n    public Rectangle(double width, double height) {\n        this.width = width;\n        this.height = height;\n    }\n    public double getArea() {\n        return width * height;\n    }\n    public double getPerimeter() {\n        return 2 * (width + height);\n    }\n}\n")),(0,o.kt)("p",null,"We can also have a ",(0,o.kt)("inlineCode",{parentName:"p"},"Circle")," class that also implements the ",(0,o.kt)("inlineCode",{parentName:"p"},"Shape")," interface:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},"class Circle implements Shape {\n    private double radius;\n    public Circle(double radius) {\n        this.radius = radius;\n    }\n    public double getArea() {\n        return Math.PI * radius * radius;\n    }\n    public double getPerimeter() {\n        return 2 * Math.PI * radius;\n    }\n}\n")),(0,o.kt)("p",null,"Now we can create a method that needs to work on shapes to take ",(0,o.kt)("inlineCode",{parentName:"p"},"Shape")," as an argument."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},"public doSomethingWithShapes(Shape s) {\n    // Do something here\n}\n")),(0,o.kt)("p",null,"This is powerful because it allows for flexibility in implementation. This is especially important where we're creating APIs for others to consume. Using an interface as an API contract helps us have a stable unchanging API while the underlying implementations change over time."),(0,o.kt)("p",null,"For example, if later on we decide to use a more efficient algorithm for calculating the area of a circle, we can change the implementation of the ",(0,o.kt)("inlineCode",{parentName:"p"},"Circle")," class, without affecting the code that uses the ",(0,o.kt)("inlineCode",{parentName:"p"},"Circle")," class. As long as the new implementation still adheres to the contract defined by the ",(0,o.kt)("inlineCode",{parentName:"p"},"Shape")," interface, the code that uses the ",(0,o.kt)("inlineCode",{parentName:"p"},"Circle")," class will continue to work correctly."),(0,o.kt)("p",null,"Therefore, the main benefit of using interfaces is that it allows for a clear separation between the interface and the implementation. The implementation can be changed without affecting the code that uses the implementation, as long as the new implementation still adheres to the contract defined by the interface."),(0,o.kt)("admonition",{type:"note"},(0,o.kt)("p",{parentName:"admonition"},'The core idea here is not to demonstrate polymorphism itself. But to show how an API can define the contract and how the implementing classes that do the work can be "pluggable" without any changes to the consumers of the API. This is the approach used by the Collection framework, so it\'s very important to learn about this.')))}h.isMDXComponent=!0}}]);