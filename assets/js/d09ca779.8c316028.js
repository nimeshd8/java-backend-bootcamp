"use strict";(self.webpackChunkjavabrains_bootcamp=self.webpackChunkjavabrains_bootcamp||[]).push([[5016],{3905:(e,t,a)=>{a.d(t,{Zo:()=>c,kt:()=>f});var n=a(7294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?o(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},o=Object.keys(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var l=n.createContext({}),p=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},c=function(e){var t=p(e.components);return n.createElement(l.Provider,{value:t},e.children)},u="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},m=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),u=p(a),m=r,f=u["".concat(l,".").concat(m)]||u[m]||d[m]||o;return a?n.createElement(f,i(i({ref:t},c),{},{components:a})):n.createElement(f,i({ref:t},c))}));function f(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=a.length,i=new Array(o);i[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[u]="string"==typeof e?e:r,i[1]=s;for(var p=2;p<o;p++)i[p]=a[p];return n.createElement.apply(null,i)}return n.createElement.apply(null,a)}m.displayName="MDXCreateElement"},7936:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>u,frontMatter:()=>o,metadata:()=>s,toc:()=>p});var n=a(7462),r=(a(7294),a(3905));const o={},i="Lambda Expressions",s={unversionedId:"java-backend-bootcamp/lambdas-and-streams/lambda-expressions",id:"java-backend-bootcamp/lambdas-and-streams/lambda-expressions",title:"Lambda Expressions",description:"Introduction",source:"@site/docs/java-backend-bootcamp/lambdas-and-streams/lambda-expressions.md",sourceDirName:"java-backend-bootcamp/lambdas-and-streams",slug:"/java-backend-bootcamp/lambdas-and-streams/lambda-expressions",permalink:"/java-backend-bootcamp/docs/java-backend-bootcamp/lambdas-and-streams/lambda-expressions",draft:!1,editUrl:"https://github.com/koushikkothagal/java-backend-bootcamp/tree/main/website/docs/java-backend-bootcamp/lambdas-and-streams/lambda-expressions.md",tags:[],version:"current",frontMatter:{},sidebar:"javaBackendBootcamp",previous:{title:"Functional programming",permalink:"/java-backend-bootcamp/docs/java-backend-bootcamp/lambdas-and-streams/functional-programming"},next:{title:"Custom Functional Interfaces",permalink:"/java-backend-bootcamp/docs/java-backend-bootcamp/lambdas-and-streams/custom-interfaces"}},l={},p=[{value:"Introduction",id:"introduction",level:2},{value:"Functional Interfaces",id:"functional-interfaces",level:2},{value:"Function",id:"function",level:3},{value:"Predicate",id:"predicate",level:3},{value:"Consumer",id:"consumer",level:3},{value:"Supplier",id:"supplier",level:3},{value:"Variants and specializations",id:"variants-and-specializations",level:3},{value:"Data type based specialization",id:"data-type-based-specialization",level:4},{value:"&quot;Operators&quot;",id:"operators",level:4},{value:"Method Reference",id:"method-reference",level:2}],c={toc:p};function u(e){let{components:t,...a}=e;return(0,r.kt)("wrapper",(0,n.Z)({},c,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"lambda-expressions"},"Lambda Expressions"),(0,r.kt)("h2",{id:"introduction"},"Introduction"),(0,r.kt)("p",null,"Lambda expressions are a way to simplify the creation of functional interfaces. A lambda expression is a shorthand syntax for creating an anonymous function. It consists of an optional list of parameters, the arrow token (",(0,r.kt)("inlineCode",{parentName:"p"},"->"),"), and a body."),(0,r.kt)("p",null,"The basic syntax of a lambda expression is as follows:"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"(parameters) -> { body }")),(0,r.kt)("p",null,"Lambda expressions can be used wherever a functional interface is expected. A functional interface is an interface that has exactly one abstract method. For this reason, functional interfaces are referred to as Single Abstract Method Interfaces (or SAM interfaces). The Java library includes several functional interfaces in the ",(0,r.kt)("inlineCode",{parentName:"p"},"java.util.function")," package, such as ",(0,r.kt)("inlineCode",{parentName:"p"},"Function"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"Consumer"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"Supplier"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"Predicate"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"Operator"),"."),(0,r.kt)("p",null,"Examples:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'// Using a lambda expression to define a Function\nFunction<Integer, Integer> add = (x) -> x + 1;\nSystem.out.println(add.apply(1)); // Output: 2\n\n// Using a lambda expression to define a Consumer\nConsumer<String> print = (s) -> System.out.println(s);\nprint.accept("Hello, World!"); // Output: "Hello, World!"\n')),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"A functional interface is an interface that has exactly one abstract method. For this reason, functional interfaces are referred to as Single Abstract Method Interfaces (or SAM interfaces). They can have multiple default and static methods though!")),(0,r.kt)("h2",{id:"functional-interfaces"},"Functional Interfaces"),(0,r.kt)("p",null,"Functional interfaces are a key feature of the Java 8 programming language, and they are used in the implementation of streams and lambda expressions. There are four main kinds of functional interfaces in Java:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Function"),(0,r.kt)("li",{parentName:"ul"},"Predicate"),(0,r.kt)("li",{parentName:"ul"},"Consumer"),(0,r.kt)("li",{parentName:"ul"},"Supplier")),(0,r.kt)("p",null,"Each of these interfaces serves a specific purpose and can be used in different ways to perform various operations on streams and data."),(0,r.kt)("h3",{id:"function"},"Function"),(0,r.kt)("p",null,"The Function interface is used to represent a function that takes one argument and produces a result. It is typically used to transform elements in some way."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Function<T, R>")," - Represents a function that takes in one argument of type T and returns a result of type R. It has the following method:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"R apply(T t)\n")),(0,r.kt)("p",null,"Example"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"Function<Integer, Integer> add = (x) -> x + 1;\nSystem.out.println(add.apply(1)); // Output: 2\n")),(0,r.kt)("p",null,"There is a related interface ",(0,r.kt)("inlineCode",{parentName:"p"},"BiFunction")," that is same as ",(0,r.kt)("inlineCode",{parentName:"p"},"Function")," except that represents a function that takes two arguments."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"R\xa0apply(T\xa0t, U\xa0u)\n")),(0,r.kt)("h3",{id:"predicate"},"Predicate"),(0,r.kt)("p",null,"The Predicate interface is used to represent a boolean-valued function of one argument."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Predicate<T>")," - Represents a function that takes in one argument of type T and returns a boolean. It has the following method:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"boolean test(T t)\n")),(0,r.kt)("p",null,"Example"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"Predicate<Integer> isEven = (x) -> x % 2 == 0;\nSystem.out.println(isEven.test(2)); // Output: true`\n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"BiPredicate")," represents a predicate (boolean-valued function) of two arguments. This is the two-arity specialization of Predicate."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"boolean\xa0test(T\xa0t, U\xa0u)\n")),(0,r.kt)("h3",{id:"consumer"},"Consumer"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"Consumer"),' interface is used to represent an operation that accepts a single input argument and returns no result. Since it doesn\'t return anything, it is meant to operate via "side effects", like printing to console, for example.'),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Consumer<T>")," - Represents an operation that takes in one argument of type T and returns no result. It has the following method:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"void accept(T t)\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'Consumer<String> print = (s) -> System.out.println(s);\nprint.accept("Hello, World!"); // Output: "Hello, World!"\n')),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"BiConsumer")," represents an operation that accepts two input arguments and returns no result. This is the two-arity specialization of Consumer. Like ",(0,r.kt)("inlineCode",{parentName:"p"},"Consumer"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"BiConsumer")," is expected to operate via side-effects."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"void\xa0accept(T\xa0t, U\xa0u)\n")),(0,r.kt)("h3",{id:"supplier"},"Supplier"),(0,r.kt)("p",null,"The Supplier interface is used to represent a supplier of results. It is typically used to generate new elements."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Supplier<T>")," - Represents a supplier of results of type T. It has the following method:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"T get()\n")),(0,r.kt)("p",null,"Example"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'Supplier<String> supplier = () -> "Hello, World!";\nSystem.out.println(supplier.get()); // Output: "Hello, World!"\n')),(0,r.kt)("h3",{id:"variants-and-specializations"},"Variants and specializations"),(0,r.kt)("h4",{id:"data-type-based-specialization"},"Data type based specialization"),(0,r.kt)("p",null,"Example: ",(0,r.kt)("inlineCode",{parentName:"p"},"DoubleFunction")," represents a function that accepts a double-valued argument and produces a result. Also ",(0,r.kt)("inlineCode",{parentName:"p"},"IntFunction"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"LongFunction"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"LongToIntFunction")," etc"),(0,r.kt)("h4",{id:"operators"},'"Operators"'),(0,r.kt)("p",null,"Example: ",(0,r.kt)("inlineCode",{parentName:"p"},"UnaryOperator")," represents an operation on a single operand that produces a result of the same type as its operand. This is a specialization of ",(0,r.kt)("inlineCode",{parentName:"p"},"Function")," for the case where the operand and result are of the same type."),(0,r.kt)("p",null,"It has the following method: ",(0,r.kt)("inlineCode",{parentName:"p"},"T apply(T t)")," ."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"UnaryOperator<Integer> square = (x) -> x * x;\nSystem.out.println(square.apply(2)); // Output: 4\n")),(0,r.kt)("p",null,"These functional interfaces are just examples of the ones provided in the package, there are many more that can be used in different situations to make the code more readable and maintainable."),(0,r.kt)("h2",{id:"method-reference"},"Method Reference"),(0,r.kt)("p",null,"A method reference is a shorthand syntax for a lambda expression that calls an existing method. It uses the double colon operator (",(0,r.kt)("inlineCode",{parentName:"p"},"::"),") to refer to a method by its name."),(0,r.kt)("p",null,"There are four types of method references:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Reference to a static method: ",(0,r.kt)("inlineCode",{parentName:"li"},"ClassName::staticMethodName"))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"// Using a method reference to a static method\nBiFunction<Integer, Integer, Integer> add = Integer::sum;\nSystem.out.println(add.apply(1, 2)); // Output: 3\n")),(0,r.kt)("ol",{start:2},(0,r.kt)("li",{parentName:"ol"},"Reference to an instance method of a particular object: ",(0,r.kt)("inlineCode",{parentName:"li"},"object::instanceMethodName"))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'String str = "Hello";\n// Using a method reference to an instance method\nSupplier<Integer> length = str::length;\nSystem.out.println(length.get()); // Output: 5\n')),(0,r.kt)("ol",{start:3},(0,r.kt)("li",{parentName:"ol"},"Reference to an instance method of an arbitrary object of a particular type: ",(0,r.kt)("inlineCode",{parentName:"li"},"ClassName::instanceMethodName"))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'List<String> strings = Arrays.asList("hi", "hello", "hey");\n// Using a method reference to an instance method\nstrings.forEach(System.out::println);\n')),(0,r.kt)("ol",{start:4},(0,r.kt)("li",{parentName:"ol"},"Reference to a constructor: ",(0,r.kt)("inlineCode",{parentName:"li"},"ClassName::new"))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"Supplier<StringBuilder> supplier = StringBuilder::new;\nStringBuilder sb = supplier.get();\n")),(0,r.kt)("p",null,"Lambda expressions and method references are a powerful feature that simplify the creation of functional interfaces. They provide a concise and expressive way to define anonymous functions and enable functional programming idioms in Java."))}u.isMDXComponent=!0}}]);