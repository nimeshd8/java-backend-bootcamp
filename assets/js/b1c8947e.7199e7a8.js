"use strict";(self.webpackChunkjavabrains_bootcamp=self.webpackChunkjavabrains_bootcamp||[]).push([[2894],{3905:(e,t,a)=>{a.d(t,{Zo:()=>p,kt:()=>f});var n=a(7294);function o(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){o(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,n,o=function(e,t){if(null==e)return{};var a,n,o={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(o[a]=e[a]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(o[a]=e[a])}return o}var c=n.createContext({}),l=function(e){var t=n.useContext(c),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},p=function(e){var t=l(e.components);return n.createElement(c.Provider,{value:t},e.children)},d="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},u=n.forwardRef((function(e,t){var a=e.components,o=e.mdxType,r=e.originalType,c=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),d=l(a),u=o,f=d["".concat(c,".").concat(u)]||d[u]||m[u]||r;return a?n.createElement(f,i(i({ref:t},p),{},{components:a})):n.createElement(f,i({ref:t},p))}));function f(e,t){var a=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=a.length,i=new Array(r);i[0]=u;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s[d]="string"==typeof e?e:o,i[1]=s;for(var l=2;l<r;l++)i[l]=a[l];return n.createElement.apply(null,i)}return n.createElement.apply(null,a)}u.displayName="MDXCreateElement"},9461:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>d,frontMatter:()=>r,metadata:()=>s,toc:()=>l});var n=a(7462),o=(a(7294),a(3905));const r={},i="Advanced Concepts",s={unversionedId:"java-backend-bootcamp/lambdas-and-streams/advanced-concepts",id:"java-backend-bootcamp/lambdas-and-streams/advanced-concepts",title:"Advanced Concepts",description:"In this section, we will cover advanced topics in lambda expressions and functional interfaces, including type inference, variable capture, and functional composition.",source:"@site/docs/java-backend-bootcamp/lambdas-and-streams/advanced-concepts.md",sourceDirName:"java-backend-bootcamp/lambdas-and-streams",slug:"/java-backend-bootcamp/lambdas-and-streams/advanced-concepts",permalink:"/java-backend-bootcamp/docs/java-backend-bootcamp/lambdas-and-streams/advanced-concepts",draft:!1,editUrl:"https://github.com/koushikkothagal/java-backend-bootcamp/tree/main/website/docs/java-backend-bootcamp/lambdas-and-streams/advanced-concepts.md",tags:[],version:"current",frontMatter:{},sidebar:"javaBackendBootcamp",previous:{title:"Best Practices",permalink:"/java-backend-bootcamp/docs/java-backend-bootcamp/lambdas-and-streams/best-practices"},next:{title:"Java Streams",permalink:"/java-backend-bootcamp/docs/java-backend-bootcamp/lambdas-and-streams/java-streams"}},c={},l=[{value:"Type Inference",id:"type-inference",level:2},{value:"Variable Capture",id:"variable-capture",level:2},{value:"Functional Composition",id:"functional-composition",level:2}],p={toc:l};function d(e){let{components:t,...a}=e;return(0,o.kt)("wrapper",(0,n.Z)({},p,a,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"advanced-concepts"},"Advanced Concepts"),(0,o.kt)("p",null,"In this section, we will cover advanced topics in lambda expressions and functional interfaces, including type inference, variable capture, and functional composition."),(0,o.kt)("h2",{id:"type-inference"},"Type Inference"),(0,o.kt)("p",null,"Type inference is a feature that allows the compiler to infer the types of the parameters and return value of a lambda expression. This means that the programmer does not have to explicitly specify the types of the parameters and return value, and the compiler can deduce them from the context in which the lambda expression is used. This can make code using lambda expressions shorter and more readable."),(0,o.kt)("p",null,"For example, if a lambda expression is assigned to a functional interface that takes a single parameter of type Integer, the compiler will infer that the lambda expression takes a single parameter of type Integer."),(0,o.kt)("p",null,"Type inference also applies to the return type of a lambda expression. If the body of the lambda expression is a single expression, the compiler will infer the return type based on the type of that expression. If the body of the lambda expression is a block of code, the return type must be explicitly specified using the return keyword."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},"// Example of type inference\nList<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);\nnumbers.stream().map(n -> n * 2).forEach(System.out::println);\n")),(0,o.kt)("p",null,'In the example above, the compiler is able to infer the type of the variable "n" based on the context in which it is used. It knows that "n" is an integer, because it is being used in the map() method of a stream of ',(0,o.kt)("inlineCode",{parentName:"p"},"Integer"),"s."),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"forEach")," method also uses type inference. We've use a method reference instead of a lambda expression and the type of the parameter is inferred by the compiler, which is Integer as well."),(0,o.kt)("p",null,"It is worth noting that type inference is not only limited to lambda expressions, it also applies to method references, constructors references and generic methods invocation."),(0,o.kt)("h2",{id:"variable-capture"},"Variable Capture"),(0,o.kt)("p",null,"Variable capture is a feature that allows a lambda expression to access variables from the enclosing scope. This can be useful, but it also has certain limitations and can lead to unexpected behavior if not used correctly."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},"// Example of variable capture\nint factor = 2;\nList<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);\nnumbers.stream().map(n -> n * factor).forEach(System.out::println);\n")),(0,o.kt)("p",null,'In the example above, the lambda expression is able to access the variable "factor" from the enclosing scope. However, it\'s important to note that the lambda expression is only able to access variables that are effectively final, meaning that their value cannot be changed after the lambda expression is defined.'),(0,o.kt)("h2",{id:"functional-composition"},"Functional Composition"),(0,o.kt)("p",null,"Functional composition is the process of combining multiple functions to create a new function. This can be useful for creating reusable blocks of code that can be easily composed and reused."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},"// Example of functional composition\nFunction<Integer, Integer> multiplyBy2 = n -> n * 2;\nFunction<Integer, Integer> add3 = n -> n + 3;\nFunction<Integer, Integer> multiplyBy2AndAdd3 = multiplyBy2.andThen(add3);\n\nList<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);\nnumbers.stream().map(multiplyBy2AndAdd3).forEach(System.out::println);\n")),(0,o.kt)("p",null,'In the example above, we have defined two functions, "multiplyBy2" and "add3", that take an integer as input and return an integer as output. We then use the ',(0,o.kt)("inlineCode",{parentName:"p"},"andThen()"),' method to compose these functions into a new function, "multiplyBy2AndAdd3". This new function takes an integer as input, multiplies it by 2 and then adds 3 to it.'),(0,o.kt)("p",null,"Functional composition is a powerful technique that can be used to create more modular and reusable code, as well as to make it more readable and maintainable by breaking it down into small, focused functions."),(0,o.kt)("p",null,"In conclusion, Type inference, variable capture, and functional composition are advanced topics in lambda expressions and functional interfaces that can help you write more concise, expressive and reusable code. By using type inference, you can reduce the amount of boilerplate code needed to define variables and expressions, By using variable capture, you can access variables from the enclosing scope, but it's important to note that the lambda expression is only able to access variables that are effectively final. And by using functional composition, you can combine multiple functions to create a new function that can be easily composed and reused. It is important to understand the behavior and limitations of these advanced topics in order to make the most of the functional features of Java 8, and improve the readability, maintainability and performance of your code."))}d.isMDXComponent=!0}}]);